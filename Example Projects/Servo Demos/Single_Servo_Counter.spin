''Single_Servo_Counter
''Author: Gavin Garner
''November 17, 2008
''This program demonstrates how to control a single RC servomotor by dedicating a cog to output signal pulses using one of 
''its two counters. Once the "MoveMotor" program is loaded into a new cog, it continuously checks the value of the "position"
''variable in the main RAM (the value of which code running on any other cog can change at any time) and creates a steady
''stream of signal pulses with a high part that is equal to the "position" value times the clock period (1/80MHz) in length
''and a low part that is 10ms in length. (This low part may need to be changed to 20ms depending on the brand of motor being
''used, but 10ms seems to work fine for Parallax/Futaba Standard Servos and gives a quicker response time than 20ms.) With an
''80MHz system clock the servo signal's pulse resolution is 12.5ns, however, the control circuitry inside most
''analog servomotors will probably not be able to distinguish between such small changes in the signal.
'Notes:
' -To use this in your own Spin code, simply declare a "position" variable as a long, start running the MoveMotor method in a
'  new cog with the "cognew(@MoveMotor,@Stack)" line and copy and paste my MoveMotor method into your own code.
' -Because this method of servo control uses a cog's counter (which runs independently of the cog's processor), in theory,
'  you could use this cog to perform other operations when it is not setting its counter (i.e., after the "phsa:=-position"
'  and before "waitcnt(period)" as long as the extra instructions take less than 10ms).
' -If you are using a Parallax/Futaba Standard Servo, the range of signal pulse widths is typically between 0.5-2.25ms, which
'  corresponds to "position" values between 40_000 (full clockwise) and 180_000 (full counterclockwise). In theory, this
'  provides you with 140_000 units of position resolution across the full range of motion. You may need to experiment with
'  changing the "position" values a little to take advantage of the full range of motion for the specific RC servo motor that
'  you are using. However, you must be careful not to force the servo to try to move beyond its mechanical stops.
' -If you find that your propeller chip or servomotor stops working for no apparent reason, it could be that the motor is
'  sending inductive spikes back into the power supply or it is simply drawing too much current and resetting the
'  propeller chip. Adding a large capacitor (e.g.,1000uF) across the power leads of the servo motor or using separate power
'  sources for the propeller chip's 3.3V regulator and the servomotor's power supply will help to fix this.

CON
  _xinfreq=5_000_000            
  _clkmode=xtal1+pll16x                 'The system clock is set at 80MHz
  
VAR
  long position                         'The assembly program will read this variable from the main Hub RAM to determine the
                                        ' servo signal's high pulse duration
  long Stack[5]                         'Alot some stack space for the cog running MoveMotor to use
  
PUB Demo                                
  cognew(MoveMotor(7),@Stack)           'Start a new cog and run the MoveMotor method on it and output pulses on Pin 7  
                                         
'The new cog that is started above continuously reads the "position" variable as it's changed by the example Spin code below
  repeat                                                                                                                 
    position:=80_000                    'Start sending 1ms servo signal high pulses (80_000 * 1/(80MHz clock freq) = 1ms)                                                        
    waitcnt(clkfreq+cnt)                'Wait for 1 second (1ms high pulses continue to be generated by the other cog)                                                                   
    position:=110_000                   'Start sending 1.375ms servo signal high pulses (Center position)                                                      
    waitcnt(clkfreq+cnt)                'Wait for 1 second (1.375ms high pulses continue to be generated by the other cog)                                                                     
    position:=40_000                    'Start sending 0.5ms servo signal high pulses (Clockwise position)                                                      
    waitcnt(clkfreq+cnt)                'Wait for 1 second (0.5ms high pulses continue to be generated by the other cog)      
    position:=180_000                   'Start sending 2.25ms servo signal high pulses (Counterclockwise position)                                                      
    waitcnt(clkfreq+cnt)                'Wait for 1 second (2.25ms high pulses continue to be generated by the other cog)      
                                                                                                                           
PUB MoveMotor(Pin) | LowTime,period                  
  dira[Pin]~~                           'Set the direction of "Pin" to be an output
  ctra[30..26]:=%00100                  'Set this cog's "A Counter" to run in single-ended NCO/PWM mode (where frqa always                                             
                                        ' accumulates to phsa and the Apin output state is bit 31 of the phsa value)                                
  ctra[5..0]:=Pin                       'Set the "A pin" of this cog's "A Counter" to be "Pin"                                           
  frqa:=1                               'Set this counter's frqa value to 1 (so 1 will be added to phsa on each clock pulse)
  position:=0                           'Start with position=0 (until the position value is changed by another cog)                 
  LowTime:=clkfreq/100                  'Set the time that the pulse will be low to 10ms
  period:=cnt                           'Store the current value of the system counter
  repeat
    phsa:=-position                     'Send a high pulse for "position" number of clock cycles
    period:=period+position+LowTime     'Calculate what the system clock's value will be at the end of this cycle's period
    waitcnt(period)                     'Wait for the system counter to reach the "period" value (end of cycle)

{Copyright (c) 2008 Gavin Garner, University of Virginia
MIT License: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and
this permission notice shall be included in all copies or substantial portions of the Software. The software is provided
as is, without warranty of any kind, express or implied, including but not limited to the warrenties of noninfringement.
In no event shall the author or copyright holder be liable for any claim, damages or other liablility, out of or in
connection with the software or the use or other dealings in the software.}                  